#!/usr/bin/env fontforge -script
"""
SVG 파일을 TTF 및 WOFF 폰트로 변환하는 스크립트입니다.
FontForge를 사용하여 SVG 외곽선을 가져와 폰트 파일을 생성합니다.
"""

import sys
import os
import glob
import fontforge
import logging
import psMat
from fontTools.ttLib.woff2 import compress


"""
입력 SVG 디렉토리와 출력 TTF 경로를 기록하고, 원래 작업 디렉토리를 반환합니다.
"""
# 입력 및 출력 경로 정보를 기록하는 헬퍼 함수
def log_initial_info(input_dir_abs, output_ttf_abs):
    original_dir = os.getcwd()
    logging.info(f"입력 SVG 디렉토리: {input_dir_abs}")
    logging.info(f"출력 TTF 경로: {output_ttf_abs}")
    return original_dir

"""
기본 메트릭이 설정된 FontForge 폰트 객체를 생성하여 반환합니다.
"""
# 폰트 객체를 생성하고 기본 메트릭을 설정하는 헬퍼 함수
def create_base_font(em_size, ascent, descent):
    logging.info("폰트 객체 생성 시작")
    font = fontforge.font()
    font.em = em_size
    font.ascent = ascent
    font.descent = descent
    font.encoding = 'UnicodeFull'
    logging.info(f"폰트 속성 설정 완료 - EM: {font.em}, Ascent: {font.ascent}, Descent: {font.descent}")
    return font

"""
폰트의 SFNT 메타데이터를 설정합니다.
"""
# 폰트 메타데이터 설정 헬퍼 함수
def setup_metadata(font, font_name, font_eng_name, family_name, style_name):
    logging.info("폰트 메타데이터 설정 시작")
    # 스타일
    ko_style = "손글씨"
    en_style = "Handwriting"
    # 페밀리, 풀네임
    ko_family = f"폰토리 {font_name}"
    en_family = f"Fontory {font_eng_name}"
    ko_fullname = f"{ko_family} {ko_style}"
    en_fullname = f"{en_family} {en_style}"
    # PS 이름 등 기본 메타데이터
    psname = font_eng_name.replace(" ", "")
    font.fontname = psname
    font.version = "1.0"
    font.familyname = family_name
    font.fullname = family_name
    font.weight = "Regular"
    font.copyright = "Generated by Fontory"
    # SFNT name entries
    for lang, family, subfam, fullname in [
        ("English (US)", en_family, en_style, en_fullname),
        ("Korean", ko_family, ko_style, ko_fullname)
    ]:
        font.appendSFNTName(lang, "Family", family)
        font.appendSFNTName(lang, "SubFamily", subfam)
        font.appendSFNTName(lang, "Fullname", fullname)
        font.appendSFNTName(lang, "PostScriptName", psname)
        font.appendSFNTName(lang, "UniqueID", f"{psname} {font.version}")
        font.appendSFNTName(lang, "Version", f"Version {font.version}")
        font.appendSFNTName(lang, "Copyright", font.copyright)
    logging.info(f"폰트 메타데이터 설정 완료 - 폰트명: {font.fontname}, 패밀리: {font.familyname}, 전체명: {font.fullname}")

"""
입력 디렉토리로 이동하고 SVG 파일 목록을 반환하며, 오류 시 종료합니다.
"""
# 입력 디렉토리에서 SVG 파일 목록을 가져오는 헬퍼 함수
def load_svg_files(input_dir_abs):
    try:
        logging.info(f"작업 디렉토리 변경 시도: {input_dir_abs}")
        os.chdir(input_dir_abs)
        logging.info(f"작업 디렉토리 변경 완료: {input_dir_abs}")
    except Exception as e:
        logging.critical(f"디렉토리 {input_dir_abs}로 이동할 수 없습니다: {e}")
        sys.exit(1)
    logging.info("SVG 파일 검색 시작")
    svg_files = glob.glob("*.svg")
    if not svg_files:
        logging.error(f"{os.getcwd()}에서 SVG 파일을 찾을 수 없습니다.")
        sys.exit(1)
    logging.info(f"SVG 파일 {len(svg_files)}개 발견, 글리프 처리 시작")
    return svg_files

"""
SVG 외곽선을 폰트에 가져와 각 글리프를 스케일 및 최적화합니다.
반환값: (가져온 개수, 건너뛴 개수, 복잡 글리프 목록, 단순 글리프 목록).
"""
# 글리프 처리 헬퍼 함수
def process_glyphs(font, svg_files):
    imported_count = 0
    skipped_count = 0
    complex_glyphs = []
    simple_glyphs = []

    for svg_index, svg_filename in enumerate(svg_files, 1):
        if svg_index % 100 == 0:
            logging.info(f"SVG 처리 진행: {svg_index}/{len(svg_files)}")
        logging.debug(f"SVG 처리 [{svg_index}/{len(svg_files)}]: '{svg_filename}' 분석 중")

        char = get_char_from_filename(svg_filename)
        if char is None:
            logging.warning(f"건너뜀 '{svg_filename}': 파일 이름에서 문자를 추출할 수 없습니다")
            skipped_count += 1
            continue

        glyph = None
        unicode_val = -1
        try:
            unicode_val = ord(char)
            logging.debug(f"글리프 처리 시작: '{svg_filename}' -> 문자 '{char}' (U+{unicode_val:04X})")
            glyph = font.createChar(unicode_val)
            glyph.importOutlines(svg_filename)

            # 스케일링 처리
            xmin, ymin, xmax, ymax = glyph.boundingBox()
            current_height = ymax - ymin
            current_width = xmax - xmin

            target_height = font.ascent + abs(font.descent)
            target_width = font.em
            scale = (target_height / current_height) * 1.05
            max_width_ratio = 0.98
            if current_width * scale > target_width * max_width_ratio:
                scale = (target_width * max_width_ratio) / current_width

            glyph.transform(psMat.scale(scale))
            # 기본 베이스라인 오프셋으로 위치 조정
            glyph.transform(psMat.translate(0, -ymin * scale + abs(font.descent) - BASELINE_ADJUST))

            # 최적화
            glyph.removeOverlap()
            glyph.correctDirection()
            glyph.addExtrema()

            xmin2, ymin2, xmax2, ymax2 = glyph.boundingBox()
            new_width = xmax2 - xmin2
            glyph.transform(psMat.translate(-xmin2, 0))
            glyph.width = int(new_width)

            # 글리프 복잡도 기록
            contour_count, point_count = 0, 0
            for contour in glyph.layers[glyph.activeLayer]:
                contour_count += 1
                point_count += len(contour)
            if point_count > 200:
                complex_glyphs.append((char, point_count))
            else:
                simple_glyphs.append((char, point_count))

            imported_count += 1

        except Exception as e:
            logging.error(f"오류: 글리프 '{char}' (U+{unicode_val:04X if unicode_val!=-1 else 'N/A'}) 처리 오류: {e}")
            skipped_count += 1
            if glyph is not None and unicode_val != -1 and unicode_val in font:
                try:
                    font.removeGlyph(glyph)
                except:
                    pass

    # 요약 로깅
    if complex_glyphs:
        complex_chars = ''.join(char for char, _ in complex_glyphs[:10])
        logging.info(f"복잡한 글리프(상위 10개): {complex_chars} (총 {len(complex_glyphs)}개)")
    logging.info(f"가져오기 결과: 총 {len(svg_files)}개 중 {imported_count}개 성공, {skipped_count}개 실패")

    return imported_count, skipped_count, complex_glyphs, simple_glyphs

"""
기본 폰트의 글리프를 메인 폰트에 병합하고, 그룹별 스케일링 및 기준선 조정을 적용합니다.
"""
def merge_base_font(font, base_font_path):
    logging.info(f"기본 폰트 병합 시작 : {base_font_path}")
    base = fontforge.open(base_font_path)
    base_scale = font.em / base.em
    GROUP_SCALE = {
        'Jamo':   0.80,   # 자모
        'Latin':  1.20,   # 영문
        'Punct':  1.00,   # 구두점·기호
    }
    punct_scale = base_scale * GROUP_SCALE.get('Punct', 0.95)
    for g in base.glyphs():
        uv = g.unicode
        if uv is None or uv < 0:
            continue
        # 1) 형태 스케일링
        if 0x1100 <= uv <= 0x11FF:
            s = base_scale * GROUP_SCALE['Jamo']
        elif (0x0041 <= uv <= 0x005A) or (0x0061 <= uv <= 0x007A):
            s = base_scale * GROUP_SCALE['Latin']
        else:
            s = punct_scale
        g.transform(psMat.scale(s))
        # 2) 기준선 정렬 및 특수 글리프 처리
        x0, y0, x1, y1 = g.boundingBox()
        midline_codes = {ord(c) for c in ('~', '-', '`')}
        quote_codes = {ord(c) for c in ('"', "'", '“', '”', '‘', '’', '^')}
        if uv in midline_codes:
            # 중간선 기준으로 수평 정렬
            midline = (font.ascent + abs(font.descent)) / 2
            g.transform(psMat.translate(0, midline - y0))
        elif uv in quote_codes:
            # 따옴표는 ascent 위치로 이동
            target_y = font.ascent
            g.transform(psMat.translate(0, target_y - y0))
        else:
            # 일반 글리프는 descent 기준으로 하단 정렬
            g.transform(psMat.translate(0, -y0 + abs(font.descent)))
        # 3) 왼쪽 정렬 및 폭 설정
        x0, y0, x1, y1 = g.boundingBox()
        w = int(x1 - x0)
        g.transform(psMat.translate(-x0, 0))
        g.width = w
    tmp_path = os.path.join(os.path.dirname(base_font_path), "__tmp_scaled_base.ttf")
    base.generate(tmp_path)
    base.close()
    pre_count = len(list(font.glyphs()))
    font.mergeFonts(tmp_path)
    post_count = len(list(font.glyphs()))
    logging.info(f"병합 완료: {post_count-pre_count}개 글리프 추가 (총 {post_count}개)")
    os.remove(tmp_path)
    # 공백 및 기본 구두점 폭 조정
    if 0x20 in font:
        font[0x20].width = int(font.em * 0.5)
    punct_chars = [0x2C, 0x2E, 0x3F, 0x21, 0x28, 0x29, 0x27, 0x22, 0x60]
    for code in punct_chars:
        if code in font:
            g = font[code]
            xmin, ymin, xmax, ymax = g.boundingBox()
            glyph_width = xmax - xmin
            target_width = int(font.em * 0.45)
            g.width = target_width
            padding = (target_width - glyph_width) / 2
            g.transform(psMat.translate(-xmin + padding, 0))


"""
출력 디렉토리가 존재하는지 확인하고 (출력 디렉토리, 기본 이름)을 반환합니다.
"""
# 출력 디렉토리 확인 및 생성 헬퍼 함수
def ensure_output_directory(output_ttf_abs, original_dir):
    logging.info("폰트 파일 생성 준비 중")
    output_dir = os.path.dirname(output_ttf_abs)
    output_basename = os.path.splitext(os.path.basename(output_ttf_abs))[0]
    if not os.path.exists(output_dir):
        try:
            logging.info(f"출력 디렉토리 생성 시도: {output_dir}")
            os.makedirs(output_dir)
            logging.info(f"출력 디렉토리 생성 완료: {output_dir}")
        except Exception as e:
            logging.critical(f"오류: 출력 디렉토리 생성 실패: {e}")
            os.chdir(original_dir)
            sys.exit(1)
    return output_dir, output_basename

"""
폰트에서 TTF 파일을 생성하고 경로와 크기를 반환합니다.
"""
# TTF/WOFF2 생성 헬퍼 함수
def generate_ttf(font, output_ttf):
    logging.info(f"TTF 파일 생성 시작: {output_ttf}")
    font.generate(output_ttf, flags=())
    file_size = os.path.getsize(output_ttf)
    logging.info(f"TTF 파일 생성 완료: {file_size:,} 바이트")
    return output_ttf, file_size


"""
TTF 파일에서 WOFF2 파일을 생성하고 경로와 크기를 반환합니다.
"""
def generate_woff2(ttf_path, output_woff2):
    logging.info(f"WOFF2 파일 생성 시작: {output_woff2}")
    compress(ttf_path, output_woff2)
    file_size = os.path.getsize(output_woff2)
    logging.info(f"WOFF2 파일 생성 완료: {file_size:,} 바이트")
    return output_woff2, file_size

"""
작업 디렉토리를 복원하고 요약을 기록하거나 실패 시 종료합니다.
"""
# 작업 디렉토리 복원 및 요약 보고 헬퍼 함수
def finalize_generation(generated_files, imported_count, original_dir):
    # 원래 작업 디렉토리로 복원
    os.chdir(original_dir)
    logging.debug(f"작업 디렉토리를 {original_dir}로 복원")
    # 결과 보고 또는 오류 시 종료
    if not generated_files:
        logging.critical("오류: 폰트 파일 생성 실패")
        sys.exit(1)
    file_list = ', '.join(f"{os.path.basename(path)} ({size:,} 바이트)" for path, size in generated_files)
    logging.info(f"폰트 생성 완료: {file_list}")
    logging.info(f"총 {imported_count}개 글리프 포함됨")

logging.basicConfig(
    level=logging.INFO,
    format='%(message)s',
    handlers=[logging.StreamHandler()]
)


# 기본 폰트 속성
DEFAULT_EM_SIZE = 1024  # 일반적인 EM 크기
DEFAULT_ASCENT = 920    # 위 여백
DEFAULT_DESCENT = 230   # 아래 여백
BASELINE_ADJUST = 50    # 베이스라인을 위로 이동시키는 오프셋 (단위: 폰트 유닛)

# 파일 이름에서 해당 글리프의 문자 또는 유니코드 포인트를 추출합니다.
def get_char_from_filename(filename):
    base = os.path.splitext(os.path.basename(filename))[0]
    try:
        # 파일 이름이 단일 문자인 경우
        if len(base) == 1:
            return base
        # U+XXXX 형식인 경우
        elif base.startswith("U+") and len(base) == 6:
            return chr(int(base[2:], 16))
    except Exception as e:
        logging.warning(f"파일 이름 '{filename}'에서 문자를 추출할 수 없습니다: {e}")
    return None

def main(input_dir_abs, output_ttf_abs, font_name, font_eng_name, family_name, style_name, base_font_path):
    # 메인 워크플로우: 입력 디렉토리에서 SVG를 읽어 폰트를 생성하고 출력합니다.
    # 작업 디렉토리 기록 및 입력/출력 정보 로깅
    original_dir = log_initial_info(input_dir_abs, output_ttf_abs)

    # 폰트 객체 생성 및 기본 속성 설정
    font = create_base_font(DEFAULT_EM_SIZE, DEFAULT_ASCENT, DEFAULT_DESCENT)

    # 폰트 메타데이터 설정
    setup_metadata(font, font_name, font_eng_name, family_name, style_name)

    # 입력 디렉토리로 이동 및 SVG 파일 목록 가져오기
    svg_files = load_svg_files(input_dir_abs)

    # 글리프 가져오기 및 처리
    imported_count, skipped_count, complex_glyphs, simple_glyphs = process_glyphs(font, svg_files)

    # 출력 디렉토리 확인 및 생성
    output_dir, output_basename = ensure_output_directory(output_ttf_abs, original_dir)

    if base_font_path and os.path.exists(base_font_path):
        merge_base_font(font, base_font_path)
    
    # 폰트 파일 생성 (TTF, WOFF2)
    generated_files = []
    # TTF 생성
    ttf_path, ttf_size = generate_ttf(font, os.path.join(output_dir, output_basename + ".ttf"))
    generated_files.append((ttf_path, ttf_size))
    # WOFF2 생성
    woff2_path, woff2_size = generate_woff2(ttf_path, os.path.join(output_dir, output_basename + ".woff2"))
    generated_files.append((woff2_path, woff2_size))

    finalize_generation(generated_files, imported_count, original_dir)

if __name__ == '__main__':
    if len(sys.argv) != 8:
        print("사용법: fontforge -script svg_to_ttf_converter.py <입력_svg_디렉토리> <출력_ttf_경로> <폰트_이름> <패밀리_이름> <스타일_이름> <기본_폰트_경로>")
        sys.exit(1)

    # 명령줄 인자 처리
    input_dir = sys.argv[1]
    output_ttf = sys.argv[2]
    fontname = sys.argv[3]
    font_eng_name = sys.argv[4]
    familyname = sys.argv[5]
    stylename = sys.argv[6]
    base_font = sys.argv[7]
    
    logging.info(f"SVG → TTF/WOFF 변환 시작")
    logging.info(f"설정 - 입력: {input_dir}, 출력: {output_ttf}")
    logging.info(f"설정 - 폰트명: {fontname}, 패밀리: {familyname}, 스타일: {stylename}")
    
    # 메인 함수 호출
    main(input_dir, output_ttf, fontname, font_eng_name, familyname, stylename, base_font)
    
    logging.info("변환 완료")
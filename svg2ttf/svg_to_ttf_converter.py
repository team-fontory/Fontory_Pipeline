#!/usr/bin/env fontforge -script
"""
SVG 파일을 TTF 및 WOFF 폰트로 변환하는 스크립트입니다.
FontForge를 사용하여 SVG 외곽선을 가져와 폰트 파일을 생성합니다.
"""

import sys
import os
import glob
import fontforge
import logging

logging.basicConfig(
    level=logging.DEBUG,
    format='%(message)s',
    handlers=[logging.StreamHandler()]
)

# 기본 폰트 속성
DEFAULT_EM_SIZE = 1024  # 일반적인 EM 크기
DEFAULT_ASCENT = 800    # 위 여백
DEFAULT_DESCENT = 200   # 아래 여백

def get_char_from_filename(filename):
    base = os.path.splitext(os.path.basename(filename))[0]
    try:
        # 파일 이름이 단일 문자인 경우
        if len(base) == 1:
            return base
        # U+XXXX 형식인 경우
        elif base.startswith("U+") and len(base) == 6:
            return chr(int(base[2:], 16))
    except Exception as e:
        logging.warning(f"파일 이름 '{filename}'에서 문자를 추출할 수 없습니다: {e}")
    return None

def main(input_dir_abs, output_ttf_abs, font_name, family_name, style_name, base_font_path):
    # 작업 디렉토리 기록
    original_dir = os.getcwd()
    logging.info(f"입력 SVG 디렉토리: {input_dir_abs}")
    logging.info(f"출력 TTF 경로: {output_ttf_abs}")

    # 폰트 객체 생성 및 기본 속성 설정
    logging.info(f"폰트 객체 생성 시작")
    font = fontforge.font()
    font.em = DEFAULT_EM_SIZE
    font.ascent = DEFAULT_ASCENT
    font.descent = DEFAULT_DESCENT
    font.encoding = 'UnicodeFull'
    logging.info(f"폰트 속성 설정 완료 - EM: {font.em}, Ascent: {font.ascent}, Descent: {font.descent}")

    # 폰트 메타데이터 설정
    logging.info(f"폰트 메타데이터 설정 시작")
    font.fontname = font_name
    font.familyname = family_name
    font.fullname = f"{family_name} {style_name}"
    font.weight = "Regular"
    font.version = "1.0"
    font.copyright = "Generated by Pipeline"
    logging.info(f"폰트 메타데이터 설정 완료 - 폰트명: {font.fontname}, 패밀리: {font.familyname}, 전체명: {font.fullname}")

    # 입력 디렉토리로 이동
    try:
        logging.info(f"작업 디렉토리 변경 시도: {input_dir_abs}")
        os.chdir(input_dir_abs)
        logging.info(f"작업 디렉토리 변경 완료: {input_dir_abs}")
    except Exception as e:
        logging.critical(f"디렉토리 {input_dir_abs}로 이동할 수 없습니다: {e}")
        sys.exit(1)

    # SVG 파일 목록 가져오기
    logging.info(f"SVG 파일 검색 시작")
    svg_files = glob.glob("*.svg")
    if not svg_files:
        logging.error(f"{os.getcwd()}에서 SVG 파일을 찾을 수 없습니다.")
        os.chdir(original_dir)
        sys.exit(1)

    logging.info(f"SVG 파일 {len(svg_files)}개 발견, 글리프 처리 시작")

    # 글리프 가져오기 및 처리
    imported_count = 0
    skipped_count = 0
    
    # 문자별 처리 시간 및 정보 추적을 위한 변수
    complex_glyphs = []
    simple_glyphs = []
    
    for svg_index, svg_filename in enumerate(svg_files, 1):
        logging.info(f"SVG 처리 [{svg_index}/{len(svg_files)}]: '{svg_filename}' 분석 중")
        
        char = get_char_from_filename(svg_filename)
        if char is None:
            logging.warning(f"건너뜀 '{svg_filename}': 파일 이름에서 문자를 추출할 수 없습니다")
            skipped_count += 1
            continue

        glyph = None
        unicode_val = -1
        try:
            unicode_val = ord(char)
            logging.info(f"글리프 처리 시작: '{svg_filename}' -> 문자 '{char}' (U+{unicode_val:04X})")
            
            # 글리프 슬롯 생성
            logging.debug(f"글리프 슬롯 생성 - 유니코드: U+{unicode_val:04X}")
            glyph = font.createChar(unicode_val)
            
            # SVG 외곽선 가져오기
            logging.info(f"SVG 외곽선 로드 시작: '{svg_filename}'")
            glyph.importOutlines(svg_filename)
            
            # 외곽선 로드 후 정보 기록
            contour_count = 0
            point_count = 0
            for contour in glyph.layers[glyph.activeLayer]:
                contour_count += 1
                point_count += len(contour)
            
            logging.info(f"외곽선 로드 완료: 경로 {contour_count}개, 점 {point_count}개")

            # 외곽선이 제대로 가져와졌는지 확인
            if len(glyph.layers[glyph.activeLayer]) == 0:
                logging.warning(f"오류: '{char}' ({svg_filename}) 외곽선을 가져올 수 없습니다.")
                glyph.clear()
                skipped_count += 1
                continue
                
            # 글리프 복잡도 기록
            if point_count > 200:
                complex_glyphs.append((char, point_count))
            else:
                simple_glyphs.append((char, point_count))

            # 글리프 최적화
            logging.info(f"글리프 최적화 시작: '{char}' (U+{unicode_val:04X})")
            
            # 겹침 제거
            logging.debug(f"겹침 제거 시작")
            glyph.removeOverlap()
            logging.debug(f"겹침 제거 완료")
            
            # 방향 수정
            logging.debug(f"방향 수정 시작")
            glyph.correctDirection()
            logging.debug(f"방향 수정 완료")
            
            # 극점 추가
            logging.debug(f"극점 추가 시작")
            glyph.addExtrema()
            logging.debug(f"극점 추가 완료")
            
            # 너비 설정
            logging.debug(f"너비 설정: {font.em}")
            glyph.width = font.em
            
            # 최적화 후 정보 재기록
            contour_count_after = 0
            point_count_after = 0
            for contour in glyph.layers[glyph.activeLayer]:
                contour_count_after += 1
                point_count_after += len(contour)
            
            logging.info(f"최적화 완료: 경로 {contour_count_after}개 (변화: {contour_count_after-contour_count:+d}), 점 {point_count_after}개 (변화: {point_count_after-point_count:+d})")
            
            logging.info(f"글리프 처리 완료: '{char}' (U+{unicode_val:04X})")
            imported_count += 1

        except Exception as e:
            logging.error(f"오류: 글리프 '{char}' (U+{unicode_val:04X if unicode_val!=-1 else 'N/A'}) 처리 오류: {e}")
            skipped_count += 1
            # 오류 발생 시 부분적으로 생성된 글리프 제거
            if glyph is not None and unicode_val != -1 and unicode_val in font:
                try:
                    font.removeGlyph(glyph)
                    logging.debug(f"오류 발생으로 글리프 '{char}' 제거")
                except:
                    pass

    # 복잡도 정보 출력
    if complex_glyphs:
        complex_chars = ''.join(char for char, _ in complex_glyphs[:10])
        logging.info(f"복잡한 글리프(상위 10개): {complex_chars} (총 {len(complex_glyphs)}개)")
        
    logging.info(f"가져오기 결과: 총 {len(svg_files)}개 중 {imported_count}개 성공, {skipped_count}개 실패")

    # 기본 폰트 병합 (선택 사항)
    if base_font_path and os.path.exists(base_font_path):
        try:
            logging.info(f"기본 폰트 병합 시작: {base_font_path}")
            # 병합 전 글리프 수 기록
            pre_merge_count = len(list(font.glyphs()))
            font.mergeFonts(base_font_path)
            # 병합 후 글리프 수 기록
            post_merge_count = len(list(font.glyphs()))
            logging.info(f"기본 폰트 병합 완료: {post_merge_count - pre_merge_count}개 글리프 추가됨 (총 {post_merge_count}개)")
        except Exception as e:
            logging.error(f"오류: 기본 폰트 병합 실패: {e}")
    elif base_font_path:
        logging.warning(f"경고: 기본 폰트 파일을 찾을 수 없습니다: {base_font_path}")

    # 출력 디렉토리 확인 및 생성
    logging.info(f"폰트 파일 생성 준비 중")
    output_dir = os.path.dirname(output_ttf_abs)
    output_basename = os.path.splitext(os.path.basename(output_ttf_abs))[0]

    if not os.path.exists(output_dir):
        try:
            logging.info(f"출력 디렉토리 생성 시도: {output_dir}")
            os.makedirs(output_dir)
            logging.info(f"출력 디렉토리 생성 완료: {output_dir}")
        except Exception as e:
            logging.critical(f"오류: 출력 디렉토리 생성 실패: {e}")
            os.chdir(original_dir)
            sys.exit(1)

    # 폰트 파일 생성 (TTF, WOFF)
    extensions = [".ttf", ".woff"]
    generated_files = []

    logging.info(f"폰트 파일 생성 시작 (총 {len(extensions)}개 형식)")
    for ext in extensions:
        output_path = os.path.join(output_dir, output_basename + ext)
        logging.info(f"{ext.upper()} 파일 생성 시작: {output_path}")
        try:
            font.generate(output_path, flags=())
            file_size = os.path.getsize(output_path)
            generated_files.append((output_path, file_size))
            logging.info(f"{ext.upper()} 파일 생성 완료: {file_size:,} 바이트")
        except Exception as e:
            logging.error(f"오류: {ext.upper()} 생성 실패: {e}")

    # 원래 디렉토리로 복귀
    os.chdir(original_dir)
    logging.debug(f"작업 디렉토리를 {original_dir}로 복원")

    if not generated_files:
        logging.critical("오류: 폰트 파일 생성 실패")
        sys.exit(1)
    else:
        file_list = ', '.join(f"{os.path.basename(path)} ({size:,} 바이트)" for path, size in generated_files)
        logging.info(f"폰트 생성 완료: {file_list}")
        logging.info(f"총 {imported_count}개 글리프 포함됨")

if __name__ == '__main__':
    if len(sys.argv) != 7:
        print("사용법: fontforge -script svg_to_ttf_converter.py <입력_svg_디렉토리> <출력_ttf_경로> <폰트_이름> <패밀리_이름> <스타일_이름> <기본_폰트_경로>")
        sys.exit(1)

    # 명령줄 인자 처리
    input_dir = sys.argv[1]
    output_ttf = sys.argv[2]
    fontname = sys.argv[3]
    familyname = sys.argv[4]
    stylename = sys.argv[5]
    base_font = sys.argv[6]
    
    logging.info(f"SVG → TTF/WOFF 변환 시작")
    logging.info(f"설정 - 입력: {input_dir}, 출력: {output_ttf}")
    logging.info(f"설정 - 폰트명: {fontname}, 패밀리: {familyname}, 스타일: {stylename}")
    
    # 메인 함수 호출
    main(input_dir, output_ttf, fontname, familyname, stylename, base_font)
    
    logging.info("변환 완료") 
#!/usr/bin/env fontforge -script
"""
SVG 파일을 TTF 및 WOFF 폰트로 변환하는 스크립트입니다.
FontForge를 사용하여 SVG 외곽선을 가져와 폰트 파일을 생성합니다.
"""

import sys
import os
import glob
import fontforge
import logging
import psMat
from fontTools.ttLib.woff2 import compress

logging.basicConfig(
    level=logging.INFO,
    format='%(message)s',
    handlers=[logging.StreamHandler()]
)

# 기본 폰트 속성
DEFAULT_EM_SIZE = 1024  # 일반적인 EM 크기
DEFAULT_ASCENT = 800    # 위 여백
DEFAULT_DESCENT = 200   # 아래 여백

def get_char_from_filename(filename):
    base = os.path.splitext(os.path.basename(filename))[0]
    try:
        # 파일 이름이 단일 문자인 경우
        if len(base) == 1:
            return base
        # U+XXXX 형식인 경우
        elif base.startswith("U+") and len(base) == 6:
            return chr(int(base[2:], 16))
    except Exception as e:
        logging.warning(f"파일 이름 '{filename}'에서 문자를 추출할 수 없습니다: {e}")
    return None

def main(input_dir_abs, output_ttf_abs, font_name, family_name, style_name, base_font_path):
    # 작업 디렉토리 기록
    original_dir = os.getcwd()
    logging.info(f"입력 SVG 디렉토리: {input_dir_abs}")
    logging.info(f"출력 TTF 경로: {output_ttf_abs}")

    # 폰트 객체 생성 및 기본 속성 설정
    logging.info(f"폰트 객체 생성 시작")
    font = fontforge.font()
    font.em = DEFAULT_EM_SIZE
    font.ascent = DEFAULT_ASCENT
    font.descent = DEFAULT_DESCENT
    font.encoding = 'UnicodeFull'
    logging.info(f"폰트 속성 설정 완료 - EM: {font.em}, Ascent: {font.ascent}, Descent: {font.descent}")

    # 폰트 메타데이터 설정
    logging.info(f"폰트 메타데이터 설정 시작")
    font.fontname = font_name
    font.familyname = family_name
    font.fullname = f"{family_name} {style_name}"
    font.weight = "Regular"
    font.version = "1.0"
    font.copyright = "Generated by Pipeline"
    logging.info(f"폰트 메타데이터 설정 완료 - 폰트명: {font.fontname}, 패밀리: {font.familyname}, 전체명: {font.fullname}")

    # 입력 디렉토리로 이동
    try:
        logging.info(f"작업 디렉토리 변경 시도: {input_dir_abs}")
        os.chdir(input_dir_abs)
        logging.info(f"작업 디렉토리 변경 완료: {input_dir_abs}")
    except Exception as e:
        logging.critical(f"디렉토리 {input_dir_abs}로 이동할 수 없습니다: {e}")
        sys.exit(1)

    # SVG 파일 목록 가져오기
    logging.info(f"SVG 파일 검색 시작")
    svg_files = glob.glob("*.svg")
    if not svg_files:
        logging.error(f"{os.getcwd()}에서 SVG 파일을 찾을 수 없습니다.")
        os.chdir(original_dir)
        sys.exit(1)

    logging.info(f"SVG 파일 {len(svg_files)}개 발견, 글리프 처리 시작")

    # 글리프 가져오기 및 처리
    imported_count = 0
    skipped_count = 0
    
    # 문자별 처리 시간 및 정보 추적을 위한 변수
    complex_glyphs = []
    simple_glyphs = []
    
    for svg_index, svg_filename in enumerate(svg_files, 1):
        if svg_index % 100 == 0:
            logging.info(f"SVG 처리 진행: {svg_index}/{len(svg_files)}")
        logging.debug(f"SVG 처리 [{svg_index}/{len(svg_files)}]: '{svg_filename}' 분석 중")
        
        char = get_char_from_filename(svg_filename)
        if char is None:
            logging.warning(f"건너뜀 '{svg_filename}': 파일 이름에서 문자를 추출할 수 없습니다")
            skipped_count += 1
            continue

        glyph = None
        unicode_val = -1
        try:
            unicode_val = ord(char)
            logging.debug(f"글리프 처리 시작: '{svg_filename}' -> 문자 '{char}' (U+{unicode_val:04X})")
            
            # 글리프 슬롯 생성
            logging.debug(f"글리프 슬롯 생성 - 유니코드: U+{unicode_val:04X}")
            glyph = font.createChar(unicode_val)
            
            # SVG 외곽선 가져오기
            logging.debug(f"SVG 외곽선 로드 시작: '{svg_filename}'")
            glyph.importOutlines(svg_filename)

            # ─────── 스케일링 처리 시작 ───────
            xmin, ymin, xmax, ymax = glyph.boundingBox()
            current_height = ymax - ymin
            target_height = font.ascent + abs(font.descent)

            extra_scale = 0.95
            scale = (target_height / current_height) * extra_scale

    
            # 2) 스케일 적용 (가로/세로 동일)
            glyph.transform(psMat.scale(scale))
    
            glyph.transform(psMat.translate(0, -ymin * scale + abs(font.descent)))
    
            # 4) 바운딩 박스 재계산
            xmin2, ymin2, xmax2, ymax2 = glyph.boundingBox()
            new_width = xmax2 - xmin2
    
            glyph.transform(psMat.translate(-xmin2, 0))
            glyph.width = int(new_width)
            
            # ─────── 스케일링 처리 끝 ───────

            # 외곽선 로드 후 정보 기록
            contour_count = 0
            point_count = 0
            for contour in glyph.layers[glyph.activeLayer]:
                contour_count += 1
                point_count += len(contour)
            
            logging.debug(f"외곽선 로드 완료: 경로 {contour_count}개, 점 {point_count}개")

            # 외곽선이 제대로 가져와졌는지 확인
            if len(glyph.layers[glyph.activeLayer]) == 0:
                logging.warning(f"오류: '{char}' ({svg_filename}) 외곽선을 가져올 수 없습니다.")
                glyph.clear()
                skipped_count += 1
                continue
                
            # 글리프 복잡도 기록
            if point_count > 200:
                complex_glyphs.append((char, point_count))
            else:
                simple_glyphs.append((char, point_count))

            # 글리프 최적화
            logging.debug(f"글리프 최적화 시작: '{char}' (U+{unicode_val:04X})")
            
            # 겹침 제거
            logging.debug(f"겹침 제거 시작")
            glyph.removeOverlap()
            logging.debug(f"겹침 제거 완료")
            
            # 방향 수정
            logging.debug(f"방향 수정 시작")
            glyph.correctDirection()
            logging.debug(f"방향 수정 완료")
            
            # 극점 추가
            logging.debug(f"극점 추가 시작")
            glyph.addExtrema()
            logging.debug(f"극점 추가 완료")
            
            # 너비 설정
            # logging.debug(f"너비 설정: {font.em}")
            # glyph.width = font.em
            
            # 최적화 후 정보 재기록
            contour_count_after = 0
            point_count_after = 0
            for contour in glyph.layers[glyph.activeLayer]:
                contour_count_after += 1
                point_count_after += len(contour)
            
            logging.debug(f"최적화 완료: 경로 {contour_count_after}개 (변화: {contour_count_after-contour_count:+d}), 점 {point_count_after}개 (변화: {point_count_after-point_count:+d})")
            
            logging.debug(f"글리프 처리 완료: '{char}' (U+{unicode_val:04X})")
            imported_count += 1

        except Exception as e:
            # logging.error(f"오류: 글리프 '{char}' (U+{unicode_val:04X if unicode_val!=-1 else 'N/A'}) 처리 오류: {e}")
            if unicode_val != -1:
                logging.error(f"오류: 글리프 '{char}' (U+{unicode_val:04X}) 처리 오류: {e}")
            else:
                logging.error(f"오류: 글리프 '{char}' 처리 오류: {e}")
            skipped_count += 1
            # 오류 발생 시 부분적으로 생성된 글리프 제거
            if glyph is not None and unicode_val != -1 and unicode_val in font:
                try:
                    font.removeGlyph(glyph)
                    logging.debug(f"오류 발생으로 글리프 '{char}' 제거")
                except:
                    pass

    # 복잡도 정보 출력
    if complex_glyphs:
        complex_chars = ''.join(char for char, _ in complex_glyphs[:10])
        logging.info(f"복잡한 글리프(상위 10개): {complex_chars} (총 {len(complex_glyphs)}개)")
        
    logging.info(f"가져오기 결과: 총 {len(svg_files)}개 중 {imported_count}개 성공, {skipped_count}개 실패")

    # 출력 디렉토리 확인 및 생성
    logging.info(f"폰트 파일 생성 준비 중")
    output_dir = os.path.dirname(output_ttf_abs)
    output_basename = os.path.splitext(os.path.basename(output_ttf_abs))[0]

    if not os.path.exists(output_dir):
        try:
            logging.info(f"출력 디렉토리 생성 시도: {output_dir}")
            os.makedirs(output_dir)
            logging.info(f"출력 디렉토리 생성 완료: {output_dir}")
        except Exception as e:
            logging.critical(f"오류: 출력 디렉토리 생성 실패: {e}")
            os.chdir(original_dir)
            sys.exit(1)
            
    
    # if base_font_path and os.path.exists(base_font_path):
    #     try:
    #         logging.info(f"기본 폰트 병합 시작: {base_font_path}")
    #         # 병합 전 글리프 수 기록
    #         pre_merge_count = len(list(font.glyphs()))
    #         font.mergeFonts(base_font_path)
    #         # 병합 후 글리프 수 기록
    #         post_merge_count = len(list(font.glyphs()))
    #         logging.info(f"기본 폰트 병합 완료: {post_merge_count - pre_merge_count}개 글리프 추가됨 (총 {post_merge_count}개)")
    #     except Exception as e:
    #         logging.error(f"오류: 기본 폰트 병합 실패: {e}")
    # elif base_font_path:
    #     logging.warning(f"경고: 기본 폰트 파일을 찾을 수 없습니다: {base_font_path}")
    # # 기본 폰트 병합
    if base_font_path and os.path.exists(base_font_path):
        try:
            logging.info(f"기본 폰트 병합 시작 : {base_font_path}")
            base = fontforge.open(base_font_path)

            base_scale = font.em / base.em

            GROUP_SCALE = {
              'Jamo':   0.80,   # 자모
              'Latin':  1.20,   # 영문
              'Punct':  1.00,   # 구두점·기호
            }
            
            punct_scale = base_scale * GROUP_SCALE.get('Punct', 0.95)
            
            for g in base.glyphs():
                uv = g.unicode
                if uv is None or uv < 0:
                    continue

                # 1) shape 스케일: 특수문자는 punct_scale 사용
                if 0x1100 <= uv <= 0x11FF:
                    s = base_scale * GROUP_SCALE['Jamo']
                elif (0x0041 <= uv <= 0x005A) or (0x0061 <= uv <= 0x007A):
                    s = base_scale * GROUP_SCALE['Latin']
                else:
                    s = punct_scale
                g.transform(psMat.scale(s))

                # 3) 베이스라인(descent) 정렬
                # g.transform(psMat.translate(0, abs(font.descent)))
                
                x0, y0, x1, y1 = g.boundingBox()
                g.transform(psMat.translate(0, -y0 + abs(font.descent)))

                # 4) 좌측 정렬 & 실제 폭으로 width 설정
                x0, y0, x1, y1 = g.boundingBox()
                w = int(x1 - x0)
                g.transform(psMat.translate(-x0, 0))
                g.width = w

            tmp_path = os.path.join(output_dir, "__tmp_scaled_base.ttf")
            base.generate(tmp_path)
            base.close()

            pre = len(list(font.glyphs()))
            font.mergeFonts(tmp_path)
            post = len(list(font.glyphs()))
            logging.info(f"병합 완료: {post-pre}개 글리프 추가 (총 {post}개)")

            # 10) 임시 파일 삭제
            os.remove(tmp_path)

            # space (U+0020)를 EM의 50% 폭으로
            if 0x20 in font:
                font[0x20].width = int(font.em * 0.5)

            # ',', '.', '?', '!' 등을 EM의 40% 폭으로
            for code in [0x2C, 0x2E, 0x3F, 0x21]:
                if code in font:
                    g = font[code]
                    # 1) 폭 설정
                    g.width = int(font.em * 0.4)
                    # 2) 왼쪽 정렬: 바운딩박스 xmin값만큼 왼쪽으로 이동
                    xmin, ymin, xmax, ymax = g.boundingBox()
                    g.transform(psMat.translate(-xmin, 0))
            
        except Exception as e:
            logging.error(f"오류: 기본 폰트 병합 실패: {e}")

    # 폰트 파일 생성 (TTF, WOFF)
    generated_files = []
    logging.info(f"폰트 파일 생성 시작")
    
    
    ext = ".ttf"
    output_path = os.path.join(output_dir, output_basename + ext)
    logging.info(f"{ext.upper()} 파일 생성 시작: {output_path}")
    try:
        font.generate(output_path, flags=())
        file_size = os.path.getsize(output_path)
        generated_files.append((output_path, file_size))
        logging.info(f"{ext.upper()} 파일 생성 완료: {file_size:,} 바이트")
    except Exception as e:
        logging.error(f"오류: {ext.upper()} 생성 실패: {e}")
    
    ext = ".woff2"
    output_path = os.path.join(output_dir, output_basename + ext)
    logging.info(f"{ext.upper()} 파일 생성 시작: {output_path}")
    try:
        compress(generated_files[0][0], output_path)
        file_size = os.path.getsize(output_path)
        generated_files.append((output_path, file_size))
        logging.info(f"{ext.upper()} 파일 생성 완료: {file_size:,} 바이트")
    except Exception as e:
        logging.error(f"오류: {ext.upper()} 생성 실패: {e}")  
        
    # extensions = [".ttf", ".woff"]
    # generated_files = []

    # logging.info(f"폰트 파일 생성 시작 (총 {len(extensions)}개 형식)")
    # for ext in extensions:
    #     output_path = os.path.join(output_dir, output_basename + ext)
    #     logging.info(f"{ext.upper()} 파일 생성 시작: {output_path}")
    #     try:
    #         font.generate(output_path, flags=())
    #         file_size = os.path.getsize(output_path)
    #         generated_files.append((output_path, file_size))
    #         logging.info(f"{ext.upper()} 파일 생성 완료: {file_size:,} 바이트")
    #     except Exception as e:
    #         logging.error(f"오류: {ext.upper()} 생성 실패: {e}")

    # 원래 디렉토리로 복귀
    os.chdir(original_dir)
    logging.debug(f"작업 디렉토리를 {original_dir}로 복원")

    if not generated_files:
        logging.critical("오류: 폰트 파일 생성 실패")
        sys.exit(1)
    else:
        file_list = ', '.join(f"{os.path.basename(path)} ({size:,} 바이트)" for path, size in generated_files)
        logging.info(f"폰트 생성 완료: {file_list}")
        logging.info(f"총 {imported_count}개 글리프 포함됨")

if __name__ == '__main__':
    if len(sys.argv) != 7:
        print("사용법: fontforge -script svg_to_ttf_converter.py <입력_svg_디렉토리> <출력_ttf_경로> <폰트_이름> <패밀리_이름> <스타일_이름> <기본_폰트_경로>")
        sys.exit(1)

    # 명령줄 인자 처리
    input_dir = sys.argv[1]
    output_ttf = sys.argv[2]
    fontname = sys.argv[3]
    familyname = sys.argv[4]
    stylename = sys.argv[5]
    base_font = sys.argv[6]
    
    logging.info(f"SVG → TTF/WOFF 변환 시작")
    logging.info(f"설정 - 입력: {input_dir}, 출력: {output_ttf}")
    logging.info(f"설정 - 폰트명: {fontname}, 패밀리: {familyname}, 스타일: {stylename}")
    
    # 메인 함수 호출
    main(input_dir, output_ttf, fontname, familyname, stylename, base_font)
    
    logging.info("변환 완료") 